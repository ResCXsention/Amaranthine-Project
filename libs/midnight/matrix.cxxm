module;
#include <type_traits>
#include <cmath>
#include <cassert>
#include <cstddef>
#include <array>
#include <initializer_list>
export module midnight:matrix;

export namespace midnight
{
	template<std::size_t R, std::size_t C, typename T>
	struct Matrix final
	{
	public:
		Matrix() = default;
		Matrix(const T fill);
		Matrix(const std::initializer_list<T> fill);
		Matrix(const Matrix<R, C, T> &other);
		
		// Matrix<R, C, T> &operator=(const Matrix<R, C, T> &other);

		T &entry(const std::size_t x, const std::size_t y);
		T &entry(const std::size_t x, const std::size_t y) const;
		auto &getData();
		auto &getData() const;
		std::size_t rows() const;
		std::size_t columns() const;

	private:
		const std::size_t length{R * C};
		T data[R][C]{0};
	};
}

export namespace midnight
{
	template<std::size_t R, std::size_t C, typename T>
	Matrix<R, C, T>::Matrix(const T fill)
	{
		data = {fill};
	}

	template<std::size_t R, std::size_t C, typename T>
	Matrix<R, C, T>::Matrix(const std::initializer_list<T> fill)
	{
		unsigned long i{0}, j{0};
		for(auto e{fill.begin()}; e != fill.end(); ++e)
		{
			data[i][j] = *e;
			++j;
			if(j >= C)
			{
				++i;
				j = 0;
			}
		}
	}

	template<std::size_t R, std::size_t C, typename T>
	Matrix<R, C, T>::Matrix(const Matrix<R, C, T> &other)
	{
		auto otherData{other.getData()};
		for(int i{0}; i < R; ++i)
		{
			for(int j{0}; j < C; ++j)
			{
				data[i][j] = otherData[i][j];
			}
		}
	}
	
	template<std::size_t R, std::size_t C, typename T>
	T &Matrix<R, C, T>::entry(const std::size_t x, const std::size_t y)
	{
		assert(x < R && "Midnight, Matrix - x out of range");
		assert(y < C && "Midnight, Matrix - y out of range");
		return data[x][y];
	}

	template<std::size_t R, std::size_t C, typename T>
	T &Matrix<R, C, T>::entry(const std::size_t x, const std::size_t y) const
	{
		assert(x < R && "Midnight, Matrix - x out of range");
		assert(y < C && "Midnight, Matrix - y out of range");
		return data[x][y];
	}

	template<std::size_t R, std::size_t C, typename T>
	auto &Matrix<R, C, T>::getData()
	{
		return data;
	}

	template<std::size_t R, std::size_t C, typename T>
	auto &Matrix<R, C, T>::getData() const
	{
		return data;
	}

	template<std::size_t R, std::size_t C, typename T>
	std::size_t Matrix<R, C, T>::rows() const
	{
		return R;
	}

	template<std::size_t R, std::size_t C, typename T>
	std::size_t Matrix<R, C, T>::columns() const
	{
		return C;
	}
}
